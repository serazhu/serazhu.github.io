<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js日期对象]]></title>
    <url>%2F2018%2F06%2F14%2Fjs%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[本文介绍了，js中日期对象的知识。包括日期对象的创建方式、日期对象的静态方法和日期对象的继承方法。 GMT时间、UTC时间和北京时间GMT时间是指格林尼治标准时间，是格林尼治天文台通过天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻，并以此来制定时间，所以格林尼治标准时是“天文学时间”，随着科技的进步，人们发现该时间不够精确，因为地球自转的速度是不均衡的，而且自转速度也会越来越慢，所以不再使用。包括时区。 UTC时间是世界协调时间，是基于原子钟的。更加精确。 北京时间即，UTC+8。 构造函数Date()直接调用忽略传入的参数，返回一个字符串。 new Date()创建日期对象new Date()参数可以是多种类型 1.不传参数1var date = new Date(); // 获取的是系统时间对象 2.传一个数字1var date = new Date(1528678434296); // 传入一个数字，即自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。 3.传多个数字用逗号隔开 依次传入表示年月日时分秒毫秒的数字，中间用逗号隔开。注意除了日期其他参数的起始值都是0，当超出范围时会进行调整。1var date = new Date(2018,5,32); // 返回Mon Jul 02 2018 00:00:00 GMT+0800 (中国标准时间)。注意和new Date(Date.UTC(2018,5,32)) 的区别,返回Mon Jul 02 2018 08:00:00 GMT+0800 (中国标准时间)。 4.传入字符串 多种形式，该字符串能被Date.parse()方法识别即可。1234var date = new Date('June 11, 2018 08:24:00'); var date = new Date('2018-06-11'); // 返回 Mon Jun 11 2018 08:00:00 GMT+0800 (中国标准时间)var date = new Date('2018-6-11'); // 返回 Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间)var date = new Date('06/11/2018'); // 返回 Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间) 当参数是’年-月-日’形式时。有前置0时，相当于UTC时间。没有时，为本地时间。参照上面实例代码。 静态方法Date.now()返回自1970-1-1 00:00:00 UTC (世界标准时间)到现在经过的毫秒数。不支持传递参数12345Date.now() +new Date() (new Date()).valueOf() // 效率较高(new Date()).getTime() // 效率较高// 效果相同都是得到自1970-1-1 00:00:00 UTC (世界标准时间)到现在经过的毫秒数 Date.parse()解析一个表示日期的字符串，并返回从1970-1-1 00:00:00 UTC (世界标准时间) 所经过的毫秒数。如果无法识别时，返回NaN。最好都是月日年 时间的格式。1.接受日期字符串：’月/日/年’1var date = Date.parse('6/13/2018'); 2.接受日期字符串：’月 日,年’1var date = Date.parse('January 12,2018'); 3.接受表示时间的字符串：’星期 月 日 年 时:分:秒 时区’ ，如果没有指定时区时，默认使用本地时间。1var date = Date.parse('Tue May 25 2004 00:00:00 GMT-0800'); 4.接收日期字符串：YYYY-MM-DD。 有前置0，相当于UTC时间，否则相当于本地时间。12new Date('2018-06-11') //返回Mon Jun 11 2018 08:00:00 GMT+0800 (中国标准时间)new Date('2018-6-11') // 返回Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间) 5.,接收日期和时间:YYYY-MM-DDThh:mm:ss1new Date('2018-06-10T14:48:00') 6.接收日期和时间:YYYY-MM-DDThh:mm:ss.sTZD如1new Date('2018-06-16T19:20:30.45+01:00') // .45表示毫秒 +01:00表示偏移一个小时 Date.UTC()返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。使用协调世界时代替本地时间。接受参数。Date.UTC(year,month[,date[,hrs[,min[,sec[,ms]]]]])如果指定参数超过合理范围，会调整其他参数来保证都在合理范围。如：Date.UTC(2017,12,32,08,24,30)日期超过范围，月份+1，月份超过范围，年份+1，最终月份+2。1new Date(Date.UTC(2017,12,32,08,24,30)) // 返回Thu Feb 01 2018 16:24:30 GMT+0800 (中国标准时间) 实例方法（继承自原型）valueOf()返回Date对象的原始值。从1970-01-01 00:00:00 UTC 开始到该日期所经过的毫秒数。 get类getTime()返回从从1970-01-01 00:00:00 UTC开始，到该日期对象所经过的毫秒数。 getDay()根据本地时间返回，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) getFullYear()根据本地时间返回，指定日期对象的年份。 getYear()已废弃，使用getFullYear() getMoth()根据本地时间返回，指定日期对象的月份。 getDate()根据本地时间返回，指定日期对象的月份的第几天（从1开始）。 getHours()根据本地时间返回，指定日期对象的小时（从0开始）。 getMinutes()根据本地时间返回，指定日期对象的分钟（从0开始）。 getSeconds()根据本地时间返回，指定日期对象的秒数（从0开始）。 getMilliseconds()根据本地时间返回，指定日期对象的毫秒数（从0开始）。 getTimezoneOffset()返回，当前时区的时区偏移。 getUTCDay()根据世界时(UTC时间)返回，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) getUTCFullYear()根据世界时(UTC时间)返回，指定日期对象的年份。 getUTCMoth()根据世界时(UTC时间)返回，指定日期对象的月份。 getUTCDate()根据世界时(UTC时间)返回，指定日期对象的月份的第几天（从1开始）。 getUTCHours()根据世界时(UTC时间)返回，指定日期对象的小时（从0开始）。 getUTCMinutes()根据世界时(UTC时间)返回，指定日期对象的分钟（从0开始）。 getUTCSeconds()根据世界时(UTC时间)返回，指定日期对象的秒数（从0开始）。 getUTCMilliseconds()根据世界时(UTC时间)返回，指定日期对象的毫秒数（从0开始）。 set类setTime()以一个表示从1970-01-01 00:00:00 UTC开始的毫秒数来，为Date对象设置时间。 setFullYear()根据本地时间，指定日期对象的年份。 setYear()已废弃，使用setFullYear() setMoth()根据本地时间，指定日期对象的月份。 setDate()根据本地时间，指定日期对象的月份的第几天（从1开始）。 setHours()根据本地时间，指定日期对象的小时（从0开始）。 setMinutes()根据本地时间，指定日期对象的分钟（从0开始）。 setSeconds()根据本地时间，指定日期对象的秒数（从0开始）。 setMilliseconds()根据本地时间，指定日期对象的毫秒数（从0开始）。 setUTCDay()根据世界时(UTC时间)，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) setUTCFullYear()根据世界时(UTC时间)，指定日期对象的年份。 setUTCMoth()根据世界时(UTC时间)，指定日期对象的月份。 setUTCDate()根据世界时(UTC时间)，指定日期对象的月份的第几天（从1开始）。 setUTCHours()根据世界时(UTC时间)，指定日期对象的小时（从0开始）。 setUTCMinutes()根据世界时(UTC时间)，指定日期对象的分钟（从0开始）。 setUTCSeconds()根据世界时(UTC时间)，指定日期对象的秒数（从0开始）。 setUTCMilliseconds()根据世界时(UTC时间)，指定日期对象的毫秒数（从0开始）。 to类（格式化方法）toJSON()返回一个符合JSON格式的日期字符串，与toISOString方法的返回结果完全相同.12var x = new Date();x.toJSON(); // "2018-06-12T01:39:03.350Z" 时区总是UTC toString()将日期对象转为字符串。和Date()一样都是返回字符串。123var x = new Date();x.toString(); // "Tue Jun 12 2018 09:39:03 GMT+0800 (中国标准时间)"Date(); // 不接受参数返回表示当前时间的字符串 toTimeString()将日期对象的时间部分转为字符串12var x = new Date();x.toTimeString(); // "09:39:03 GMT+0800 (中国标准时间)" toDateString()将日期对象的日期部分转为字符串12var x = new Date();x.toDateString(); // "Tue Jun 12 2018" toGMTString()已废弃 toUTCString()将日期对象转为用UTC时区表示的字符串12var x = new Date();x.toUTCString(); // "Tue, 12 Jun 2018 01:39:03 GMT" toISOString()将日期对象转为ISO格式的字符串12var x = new Date();x.toISOString(); // "2018-06-12T01:39:03.350Z" 时区总是UTC toLocaleString()将日期对象转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleString(); // "2018/6/12 上午9:39:03" toLocaleDateString()将日期对象的日期部分转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleDateString(); // "2018/6/12" toLocaleTimeString()将日期对象的时间部分转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleTimeString(); // "上午9:39:03" toSource()/toLocaleFormat()非标准的,不要使用。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>日期对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编写可维护的JavaScript》读书笔记之事件处理]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%8A%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文主要记录《编写可维护的JavaScript》一书中关于事件处理的一些编程技巧。加深自己的理解，应用到实际项目中。 事件处理在js中非常重要。所有js均通过事件处理来绑定到UI上。 反面实例12345678910111213141516function handleClick(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show';&#125;addListener(element,'click',handleClick); // 此处为封装的兼容性事件监听函数function addListener(ele, type, handler)&#123; if(ele.addEventListener)&#123; ele.addEventListener(type, handler); &#125;else&#123; ele.attachEvent('on' + type, function()&#123; return handler.call(ele, event); &#125;) &#125;&#125; 事件处理程序还包含了应用逻辑。应用逻辑是和应用相关的功能性代码，而不是和某一个用户行为完全相关的。 如上例，是点击某个元素，根据点击位置来显示目标元素。但有可能，同时有其他用户行为来，显示目标元素（例如，点击其他元素或，鼠标移入某个元素）。存在多个用户行为来显示目标元素的话，就要复制相同的代码。 第一步：隔离应用逻辑将上例代码中的应用逻辑，隔离出来1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event); &#125;, showPopup = function(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 应用逻辑全部转到myApplication.showPopup方法中，事件处理程序myApplication.handleClick只负责触发应用逻辑。 第二步：不分发事件对象 应用逻辑不应依赖于event事件对象。原因： 透明清晰的API 便于测试 上例代码中，应用逻辑代码只使用了事件对象的clientX和clientY属性。1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 myApplication.handleClick方法，将x坐标和y坐标传入myApplication.showPopup方法中，可以很清晰的看到myApplication.showPopup方法希望传入的参数。 事件处理程序和阻止默认事件、阻止事件冒泡事件处理程序，应在进入应用逻辑之前，针对event对象做任何必要的操作，包括阻止默认事件和阻止事件冒泡12345678910111213141516var myApplication = &#123; handleClick = function(event)&#123; event.stopPropagation(); event.preventDefault(); this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>读书笔记 编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script元素相关知识]]></title>
    <url>%2F2018%2F05%2F19%2Fscript%E5%85%83%E7%B4%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了，script元素的属性、动态加载js的方法、script标签在文档放置位置建议。js是阻塞式的语言。一般，页面中&lt;script&gt;标签出现，会使整个页面因脚本加载、解析、运行而出现等待，页面的下载和解析过程必须停下。 script元素属性type指示脚本的MIME类型。例如：type=&quot;text/javascript&quot; 、type=&quot;text/x-template&quot; MIME叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等。在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。 以上来自知乎：https://www.zhihu.com/question/60495696 src规定外部脚本的url defer规定脚本是否延迟执行。适用于外部脚本（ie4~ie7浏览器还适用于内联脚本）。当defer=&quot;defer&quot;时，脚本非阻塞式立即下载，和渲染后续文档元素，并行进行（异步），直到页面加载完成才执行脚本，在DOMContentLoaded事件触发之前完成（在window.onload之前执行）。 asyns非阻塞式立即下载，和渲染后续文档元素，并行进行（异步）。脚本下载完成后，立即执行。仅适用于外部脚本。 charset定义外部脚本文件中所使用的字符编码。 language不赞成使用，用type代替。规定脚本语言。 在页面加入script的几种方式1.用script标签直接插入脚本当浏览器遇到&lt;script&gt;标签，会停下来，下载外部文件代码(如果存在src引入的外部代码)，然后解析并运行这些代码。此过程，页面解析和用户交互是完全被阻塞的。可以利用script元素的属性改为非阻塞式。 2.动态加载脚本动态加载的js脚本，下载时是非阻塞的运行时是阻塞的。 2.1通过设置src属性动态加载脚本（异步）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.src = "https://cdn.bootcss.com/vue/2.5.16/vue.js";head.appendChild(script); 直到script标签插入文档，才会开始下载脚本。 2.2通过文本节点插入到script标签中（同步、低版本ie不支持）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.appendChild(document.createTextNode("var a = 1;"));head.appendChild(script); script标签插入文档，脚本立即执行。 2.3通过script标签text属性插入（同步） IE8-浏览器将&lt;script&gt;元素视为一个特殊的元素，不允许DOM访问其子节点，使用appendChild()方法或innerHTML属性都会报错 12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.text = "var a = 1;";head.appendChild(script); script标签插入文档，脚本立即执行。 2.4通过ajax插入脚本（异步）12345678910111213var xhr = new XMLHttpRequest();xhr.open('get','file1.js',true);xhr.onreadyStateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.text = xhr.responseText; document.getElementsByTagName('head')[0].appendChild('script'); &#125; &#125;&#125;xhr.send(null); js脚本必须与页面是同一个域。script标签插入文档，脚本立即执行。 2.5通过jq方法getScript插入脚本（异步）通过HTTP GET形式的加载JavaScript文件并运行它。123$.getScript('file1.js',function()&#123; alert('load');&#125;) 等同于12345678$.ajax(&#123; url:'file1.js', type:'get', dataType:'script', success:function()&#123; alert('load'); &#125;&#125;) 支持跨域脚本文件。异步添加脚本，访问该脚本的变量或函数时，应在回调函数中进行。 加载脚本并使用脚本代码的方法封装src引入js脚本封装12345678910111213141516171819function getUrlJs(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; if(typeof callback === 'function')&#123; script.onload = script.onreadyStateChange = function()&#123; /* * !script.readyState判断为现代浏览器 * script.readyState和script.readyState判断为ie低版本浏览器 */ if(!script.readyState || script.readyState === 'load' || script.readyState === 'complete')&#123; script.onload = script.onreadyStateChange = null; callback(); &#125; &#125; &#125; document.getElementsByTagName('head')[0].appendChild(script);&#125; ajax引入js脚本封装1234567891011121314151617181920212223242526272829function getAjaxJs(url,callback)&#123; var xhr = null; if(window.XMLHttpReques)&#123; xhr = new XMLHttpReques(); &#125;else if(window.ActiveXObject('Microsoft.XMLHTTP'))&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('get',url,true); xhr.onreadySateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; try&#123; // 现代浏览器 script.appenChild(document.createTextNode(xhr.responseText)) &#125;catch()&#123; // ie低版本浏览器 script.text = xhr.responseText; &#125; document.getElementsByTagName('head')[0].appendChild(script); callback(); &#125; &#125; &#125; xhr.send();&#125; script标签相关性能优化 与页面渲染相关(需要在页面渲染之前执行，如和css相关设置rem等)放到head标签内,其他与页面dom操作相关的脚本放到紧邻标签之前。 适当应用内部脚本（某个页面单独应用时），尤其移动端可减少http请求，优化性能。 一些需要触发某些条件才执行的脚本（一些事件或者判断客户端等），采用动态加载的方式添加到页面。 减少script标签引入外部脚本的数量，减少http请求。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>script标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server安装及配置]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp-server%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了，http-server的安装方式及端口的设置 1.安装进行全局安装1npm install http-server -g 2.启动服务2.1 使用默认端口8080直接在项目目录打开命令行工具执行http-server,即把项目资源托管到http://127.0.0.1:8080 2.2 自己设置端口直接在项目目录打开命令行工具执行 http-server -p 3000，即把项目资源托管到http://127.0.0.1:3000其中-p表示设置端口 3000为设置的端口号 3.关闭服务执行ctrl+c]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
