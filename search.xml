<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《编写可维护的JavaScript》读书笔记之事件处理]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%8A%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文主要记录《编写可维护的JavaScript》一书中关于事件处理的一些编程技巧。加深自己的理解，应用到实际项目中。 事件处理在js中非常重要。所有js均通过事件处理来绑定到UI上。 反面实例12345678910111213141516function handleClick(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show';&#125;addListener(element,'click',handleClick); // 此处为封装的兼容性事件监听函数function addListener(ele, type, handler)&#123; if(ele.addEventListener)&#123; ele.addEventListener(type, handler); &#125;else&#123; ele.attachEvent('on' + type, function()&#123; return handler.call(ele, event); &#125;) &#125;&#125; 事件处理程序还包含了应用逻辑。应用逻辑是和应用相关的功能性代码，而不是和某一个用户行为完全相关的。 如上例，是点击某个元素，根据点击位置来显示目标元素。但有可能，同时有其他用户行为来，显示目标元素（例如，点击其他元素或，鼠标移入某个元素）。存在多个用户行为来显示目标元素的话，就要复制相同的代码。 第一步：隔离应用逻辑将上例代码中的应用逻辑，隔离出来1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event); &#125;, showPopup = function(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 应用逻辑全部转到myApplication.showPopup方法中，事件处理程序myApplication.handleClick只负责触发应用逻辑。 第二步：不分发事件对象 应用逻辑不应依赖于event事件对象。原因： 透明清晰的API 便于测试 上例代码中，应用逻辑代码只使用了事件对象的clientX和clientY属性。1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 myApplication.handleClick方法，将x坐标和y坐标传入myApplication.showPopup方法中，可以很清晰的看到myApplication.showPopup方法希望传入的参数。 事件处理程序和阻止默认事件、阻止事件冒泡事件处理程序，应在进入应用逻辑之前，针对event对象做任何必要的操作，包括阻止默认事件和阻止事件冒泡12345678910111213141516var myApplication = &#123; handleClick = function(event)&#123; event.stopPropagation(); event.preventDefault(); this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>读书笔记 编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script元素相关知识]]></title>
    <url>%2F2018%2F05%2F19%2Fscript%E5%85%83%E7%B4%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了，script元素的属性、动态加载js的方法、script标签在文档放置位置建议。js是阻塞式的语言。一般，页面中&lt;script&gt;标签出现，会使整个页面因脚本加载、解析、运行而出现等待，页面的下载和解析过程必须停下。 script元素属性type指示脚本的MIME类型。例如：type=&quot;text/javascript&quot; 、type=&quot;text/x-template&quot; MIME叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等。在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。 以上来自知乎：https://www.zhihu.com/question/60495696 src规定外部脚本的url defer规定脚本是否延迟执行。适用于外部脚本（ie4~ie7浏览器还适用于内联脚本）。当defer=&quot;defer&quot;时，脚本非阻塞式立即下载，和渲染后续文档元素，并行进行（异步），直到页面加载完成才执行脚本，在DOMContentLoaded事件触发之前完成（在window.onload之前执行）。 asyns非阻塞式立即下载，和渲染后续文档元素，并行进行（异步）。脚本下载完成后，立即执行。仅适用于外部脚本。 charset定义外部脚本文件中所使用的字符编码。 language不赞成使用，用type代替。规定脚本语言。 在页面加入script的几种方式1.用script标签直接插入脚本当浏览器遇到&lt;script&gt;标签，会停下来，下载外部文件代码(如果存在src引入的外部代码)，然后解析并运行这些代码。此过程，页面解析和用户交互是完全被阻塞的。可以利用script元素的属性改为非阻塞式。 2.动态加载脚本动态加载的js脚本，下载时是非阻塞的运行时是阻塞的。 2.1通过设置src属性动态加载脚本（异步）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.src = "https://cdn.bootcss.com/vue/2.5.16/vue.js";head.appendChild(script); 直到script标签插入文档，才会开始下载脚本。 2.2通过文本节点插入到script标签中（同步、低版本ie不支持）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.appendChild(document.createTextNode("var a = 1;"));head.appendChild(script); script标签插入文档，脚本立即执行。 2.3通过script标签text属性插入（同步） IE8-浏览器将&lt;script&gt;元素视为一个特殊的元素，不允许DOM访问其子节点，使用appendChild()方法或innerHTML属性都会报错 12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.text = "var a = 1;";head.appendChild(script); script标签插入文档，脚本立即执行。 2.4通过ajax插入脚本（异步）12345678910111213var xhr = new XMLHttpRequest();xhr.open('get','file1.js',true);xhr.onreadyStateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.text = xhr.responseText; document.getElementsByTagName('head')[0].appendChild('script'); &#125; &#125;&#125;xhr.send(null); js脚本必须与页面是同一个域。script标签插入文档，脚本立即执行。 2.5通过jq方法getScript插入脚本（异步）通过HTTP GET形式的加载JavaScript文件并运行它。123$.getScript('file1.js',function()&#123; alert('load');&#125;) 等同于12345678$.ajax(&#123; url:'file1.js', type:'get', dataType:'script', success:function()&#123; alert('load'); &#125;&#125;) 支持跨域脚本文件。异步添加脚本，访问该脚本的变量或函数时，应在回调函数中进行。 加载脚本并使用脚本代码的方法封装src引入js脚本封装12345678910111213141516171819function getUrlJs(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; if(typeof callback === 'function')&#123; script.onload = script.onreadyStateChange = function()&#123; /* * !script.readyState判断为现代浏览器 * script.readyState和script.readyState判断为ie低版本浏览器 */ if(!script.readyState || script.readyState === 'load' || script.readyState === 'complete')&#123; script.onload = script.onreadyStateChange = null; callback(); &#125; &#125; &#125; document.getElementsByTagName('head')[0].appendChild(script);&#125; ajax引入js脚本封装1234567891011121314151617181920212223242526272829function getAjaxJs(url,callback)&#123; var xhr = null; if(window.XMLHttpReques)&#123; xhr = new XMLHttpReques(); &#125;else if(window.ActiveXObject('Microsoft.XMLHTTP'))&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('get',url,true); xhr.onreadySateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; try&#123; // 现代浏览器 script.appenChild(document.createTextNode(xhr.responseText)) &#125;catch()&#123; // ie低版本浏览器 script.text = xhr.responseText; &#125; document.getElementsByTagName('head')[0].appendChild(script); callback(); &#125; &#125; &#125; xhr.send();&#125; script标签相关性能优化 与页面渲染相关(需要在页面渲染之前执行，如和css相关设置rem等)放到head标签内,其他与页面dom操作相关的脚本放到紧邻标签之前。 适当应用内部脚本（某个页面单独应用时），尤其移动端可减少http请求，优化性能。 一些需要触发某些条件才执行的脚本（一些事件或者判断客户端等），采用动态加载的方式添加到页面。 减少script标签引入外部脚本的数量，减少http请求。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>script标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server安装及配置]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp-server%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了，http-server的安装方式及端口的设置 1.安装进行全局安装1npm install http-server -g 2.启动服务2.1 使用默认端口8080直接在项目目录打开命令行工具执行http-server,即把项目资源托管到http://127.0.0.1:8080 2.2 自己设置端口直接在项目目录打开命令行工具执行 http-server -p 3000，即把项目资源托管到http://127.0.0.1:3000其中-p表示设置端口 3000为设置的端口号 3.关闭服务执行ctrl+c]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
