<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js运算符知识]]></title>
    <url>%2F2018%2F06%2F17%2Fjs%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了，js运算符的知识。包括js中的表达式、运算符的分类、运算符的优先级、运算符的结合性、运算符的运算顺序等知识。 前提知识-表达式表达式是一组代码的集合，它返回一个值。 原始表达式原始表达式是表达式的最小单位，它不再包含其他表达式。常量（变量的一种，一般是全大写字母的形式）、变量、直接量、关键字。123456COUNT // 常量i // 变量123 // 数字直接量'hello' // 字符串直接量/pattern/ // 正则表达式直接量null // 关键字 初始化表达式1234567[1,2,3] // 数组初始化表达式// 对象初始化表达式&#123; age: 18, seet: male&#125; 函数定义表达式123var = function add(x,y)&#123; return x + y;&#125; 属性访问表达式12arr.length;arr['length'] 函数调用表达式函数调用表达式以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表。先计算函数表达式，再计算参数表达式。1add(1,2); 对象创建表达式1new Object(); 运算符的分类赋值运算符12345678var a = 1; //赋值a += 10; // 加法赋值，有副作用， a = a + 10的简写a -= 1; // 减法赋值，有副作用， a = a - 1的简写a *= 3; // 乘法赋值，有副作用， a = a * 3的简写a %= 2; // 求余赋值，有副作用， a = a % 2的简写a /= 3; // 除法赋值，有副作用， a = a / 3的简写var foo = ["one", "two", "three"];var [one, two, three] = foo; // 解构赋值 相等运算符等于 当两边操作数类型相同时，按全等规则判断。 当两边操作数类型不同时，先进行隐式类型转换，规则如下： undefined和null相等，undefined、null和其他任何类型都不相等。 如果有一个操作数是数字类型或布尔类型，则把另一个操作数转为数字类型在进行比较。 如果有一个操作数是对象，另一个操作数是原始类型值，先把对象转为原始类型值，先调用valueOf方法，如果返回值为原始类型，则按照以上的规则比较，否则再继续调用toString方法转为原始类型值。日期对象会先调用toString方法。 1undefined == null; // true 大牛的总结：相等运算符 全等 当两边操作数类型不同时，返回false。 当两边操作数类型相同时，原始类型比较的是值，对象类型比较的是引用地址。相同返回true，不同返回false。NaN不等任何数值，包括它本身。注意，当两个操作数都是字符串时，比较的是字符串的编码。 比较运算符 比较运算符包括:大于运算符，小于运算符，大于等于运算符，小于等于运算符 数值的比较，两个操作数都是数值，有一个操作数为数值，把另一个操作数转为数值。 字符串的比较，即字符串编码的比较，两个操作数都是字符串。 如果操作数是引用类型，现将操作数转为原始类型值，先调用valueOf方法，如果返回原始值，则按照上面两跳规则进行判断，否则继续调用toString方法，然后再按照上面的规则进行判断。 乘性运算符 乘性运算符包括:乘法运算符，除法运算符，求模运算符 运算规则为，将操作数转为数字再进行计算。不能转为数值时，返回NaN。 逻辑与和逻辑或逻辑与返回值为运行到哪个操作数的返回值。如果第一个操作数为true，返回值为第二个操作数的返回值。如果第一个操作数为false，返回值为第一个操作数的返回值。 对两个布尔值进行运算，如果其中有一个为false则返回值为false，如果两个值都为true则返回值为true。 对两个表达式进行运算，如果其中有一个为false则返回值为false，如果两个值都为true则返回值为true。一般用在判断语句中,两个表达式的返回值都为布尔值。 对两个表达式进行运算，如果第一个表达式返回true，则运行第二个表达式，否则不运行第二个表达式。短路写法，一般第一个表达式为判断条件，第二个表达式是一个执行操作。12345678// 应用在判断语句中var a = 10;var b = 20;if(a &gt; 0 &amp;&amp; b &lt; 50)&#123; console.log('逻辑与')&#125;// 短路写法，第一个操作数返回true，运行第二个操作数fn &amp;&amp; fn(); 逻辑或返回值为运行到哪个操作数的返回值。如果第一个操作数为false，返回值为第二个操作数的返回值。如果第一个操作数为true，返回值为第一个操作数的返回值。 对两个布尔值进行运算，如果有一个为true返回值为true，如果两个都为false返回值为false。 对两个表达式进行运算，如果有一个表达式返回true则返回值为true，如果两个表达式都返回false则返回值为false 对两个表达式进行运算，如果第一个表达式返回false，则运行第二个表达式，否则不运行第二个表达值。短路写法，用于赋值操作，一般第一个表达式为判断条件，第二个表达式是一个执行操作。12345678// 应用在判断语句中var a = 10;var b = 20;if(a &gt; 0 || b &gt; 50)&#123; console.log('逻辑或')&#125;// 短路写法，第一个操作数返回false，进行赋值obj.age &amp;&amp; obj.age = 18; 条件运算符condition ? expression1 : expression1当条件为true时，运算符会返回表达式1的值，当条件为false时，运算符会返回表达式2的值。结合性为从左向右运算。 逗号运算符逗号运算符对它的每个操作数求值（从左到右），并返回最后一个操作数的值。是优先级最低的运算符。 加性运算符加法运算符 如果有一个操作数是字符串类型，另一个操作数是原始类型值，将另一个操作数转为字符串，然后进行字符串拼接。 如果有一个操作数是字符串类型，另一个操作数是复杂类型值，先将另一个操作数转为原始类型值（先调用valueOf方法，不是原始值再调用toString方法），如果不是字符串类型，然后再转为字符串，进行字符串拼接。 如果一个操作数是数字类型，另一个操作数是除了字符串之外的原始类型值，就将操作数转为数字，然后进行数字的相加。 如果一个或两个操作数是复杂类型值，就将操作数转为原始值（先调用valueOf方法，不是原始值再调用toString方法），然后再按照上面的规则进行字符串拼接或数字的相加。 减法运算符将两个操作数都转为数字然后进行相减。其中复杂类型值先转为原始值（先调用valueOf方法，不是原始值再调用toString方法），然后再转为数字。 一元运算符 只能操作一个表达式的运算符叫做一元运算符。 一元加运算符将后面的操作数转为数字类型，和使用Number方法效果相同，返回数字或NaN。 原始类型值 数字：返回数字本身，包括负数也是返回其本身 字符串：空字符串转为0，数字字符串转为对应的数值，其他转为NaN null：转为0 undefined：转为NaN 布尔值：true转为1，false转为0 引用类型值 先调用vlaueOf方法，如果返回值是原始类型值，按照原始类型值的规则进行转换，如果不是原始类型值，再继续调用toString方法，得到原始类型值，再按照原始类型值的规则进行转换。 一元减 数字：返回数字对应的负数 其他：先将操作数转为数字（即进行和一元加一样的操作），再返回数值对应的负数。 递增和递减（有副作用）把所有的操作数转为数字类型，然后进行加1或减1的操作。 前置：先进行加或减，再进行运算 后置：先进行运算，再进行加或减 逻辑非把操作数转为布尔类型，然后再取反。 按位非操作数是数字时，运算效果是，对操作数取负值，然后减1。 typeoftypeof返回操作数的类型。可以对操作数使用括号包裹，用以表示优先级。返回值为字符串。包括’number’,’boolean’,’null’,’undefined’,’string’,’object’。 void对给定的表达式进行求值，然后返回undefined delete（有副作用）用于删除对象的某个属性。成功删除时返回true，否则返回false。 如果试图删除的属性不存在，那么将不起作用，但任然返回true。 只会删除对象上自身属性，不会删除原型链上的属性 使用var、let、const声明的变量不能被删除，返回false。直接声明的变量可以被删除，因为这个变量是全局对象的属性。 使用definedProperty方法设置为不可配置的属性不能删除。 运算符的优先级 属性访问的优先级最高，其次是一元运算符，再次是乘性运算符，再次是加性运算符，再次是比较运算符，再次是相等运算符，再次是逻辑或和逻辑与，再次是条件运算符，再次是赋值运算符，再次是逗号运算符。 运算符的结合性在运算符优先级相同的情况下，运算的先后顺序。一元运算符、三目运算、赋值运算符是右结合的其他都是左结合。 运算顺序运算符的优先级和结合性规定了，它们在复杂表达式中的运算顺序。但并没有规定子表达式的计算过程中的运算顺序。js总是严格按照从左至右的顺序来计算表达式。 复杂类型值的toString和valueOf的执行顺序 复杂类型值转为字符串时，先调用toString，返回值不为原始类型值时，继续调用valueOf，得到原始类型值，再转为字符串类型，如果还得不到原始类型值则会报错 复杂类型值转为数值时，先调用valueOf，返回值不为原始类型值时，继续调用toString，得到原始类型值，再转为数值类型，如果还得不到原始类型值则会报错 复杂类型值转为原始类型值时，先调用valueOf，返回值不为原始类型值时，继续调用toString，如果还得不到原始类型值则会报错 日期对象转为原始类型值时，先调用toString1234567891011var obj = &#123; valueOf: function()&#123;return 10&#125;, toString: function()&#123;return 'abc'&#125;&#125;var newObj = &#123; valueOf: function()&#123;return 10&#125;, toString: function()&#123;return 'abc'&#125;&#125;alert(obj); // 返回'abc'，相当于转为字符串console.log(String(obj)) // 返回'abc'，相当于转为字符串console.log('' + obj) // 转为原始值]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>js运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js日期对象]]></title>
    <url>%2F2018%2F06%2F14%2Fjs%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[本文介绍了，js中日期对象的知识。包括日期对象的创建方式、日期对象的静态方法和日期对象的继承方法。 GMT时间、UTC时间和北京时间GMT时间是指格林尼治标准时间，是格林尼治天文台通过天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻，并以此来制定时间，所以格林尼治标准时是“天文学时间”，随着科技的进步，人们发现该时间不够精确，因为地球自转的速度是不均衡的，而且自转速度也会越来越慢，所以不再使用。包括时区。 UTC时间是世界协调时间，是基于原子钟的。更加精确。 北京时间即，UTC+8。 构造函数Date()直接调用忽略传入的参数，返回一个字符串。 new Date()创建日期对象new Date()参数可以是多种类型 1.不传参数1var date = new Date(); // 获取的是系统时间对象 2.传一个数字1var date = new Date(1528678434296); // 传入一个数字，即自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。 3.传多个数字用逗号隔开 依次传入表示年月日时分秒毫秒的数字，中间用逗号隔开。注意除了日期其他参数的起始值都是0，当超出范围时会进行调整。1var date = new Date(2018,5,32); // 返回Mon Jul 02 2018 00:00:00 GMT+0800 (中国标准时间)。注意和new Date(Date.UTC(2018,5,32)) 的区别,返回Mon Jul 02 2018 08:00:00 GMT+0800 (中国标准时间)。 4.传入字符串 多种形式，该字符串能被Date.parse()方法识别即可。1234var date = new Date('June 11, 2018 08:24:00'); var date = new Date('2018-06-11'); // 返回 Mon Jun 11 2018 08:00:00 GMT+0800 (中国标准时间)var date = new Date('2018-6-11'); // 返回 Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间)var date = new Date('06/11/2018'); // 返回 Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间) 当参数是’年-月-日’形式时。有前置0时，相当于UTC时间。没有时，为本地时间。参照上面实例代码。 静态方法Date.now()返回自1970-1-1 00:00:00 UTC (世界标准时间)到现在经过的毫秒数。不支持传递参数12345Date.now() +new Date() (new Date()).valueOf() // 效率较高(new Date()).getTime() // 效率较高// 效果相同都是得到自1970-1-1 00:00:00 UTC (世界标准时间)到现在经过的毫秒数 Date.parse()解析一个表示日期的字符串，并返回从1970-1-1 00:00:00 UTC (世界标准时间) 所经过的毫秒数。如果无法识别时，返回NaN。最好都是月日年 时间的格式。1.接受日期字符串：’月/日/年’1var date = Date.parse('6/13/2018'); 2.接受日期字符串：’月 日,年’1var date = Date.parse('January 12,2018'); 3.接受表示时间的字符串：’星期 月 日 年 时:分:秒 时区’ ，如果没有指定时区时，默认使用本地时间。1var date = Date.parse('Tue May 25 2004 00:00:00 GMT-0800'); 4.接收日期字符串：YYYY-MM-DD。 有前置0，相当于UTC时间，否则相当于本地时间。12new Date('2018-06-11') //返回Mon Jun 11 2018 08:00:00 GMT+0800 (中国标准时间)new Date('2018-6-11') // 返回Mon Jun 11 2018 00:00:00 GMT+0800 (中国标准时间) 5.,接收日期和时间:YYYY-MM-DDThh:mm:ss1new Date('2018-06-10T14:48:00') 6.接收日期和时间:YYYY-MM-DDThh:mm:ss.sTZD如1new Date('2018-06-16T19:20:30.45+01:00') // .45表示毫秒 +01:00表示偏移一个小时 Date.UTC()返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。使用协调世界时代替本地时间。接受参数。Date.UTC(year,month[,date[,hrs[,min[,sec[,ms]]]]])如果指定参数超过合理范围，会调整其他参数来保证都在合理范围。如：Date.UTC(2017,12,32,08,24,30)日期超过范围，月份+1，月份超过范围，年份+1，最终月份+2。1new Date(Date.UTC(2017,12,32,08,24,30)) // 返回Thu Feb 01 2018 16:24:30 GMT+0800 (中国标准时间) 实例方法（继承自原型）valueOf()返回Date对象的原始值。从1970-01-01 00:00:00 UTC 开始到该日期所经过的毫秒数。 get类getTime()返回从从1970-01-01 00:00:00 UTC开始，到该日期对象所经过的毫秒数。 getDay()根据本地时间返回，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) getFullYear()根据本地时间返回，指定日期对象的年份。 getYear()已废弃，使用getFullYear() getMoth()根据本地时间返回，指定日期对象的月份。 getDate()根据本地时间返回，指定日期对象的月份的第几天（从1开始）。 getHours()根据本地时间返回，指定日期对象的小时（从0开始）。 getMinutes()根据本地时间返回，指定日期对象的分钟（从0开始）。 getSeconds()根据本地时间返回，指定日期对象的秒数（从0开始）。 getMilliseconds()根据本地时间返回，指定日期对象的毫秒数（从0开始）。 getTimezoneOffset()返回，当前时区的时区偏移。 getUTCDay()根据世界时(UTC时间)返回，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) getUTCFullYear()根据世界时(UTC时间)返回，指定日期对象的年份。 getUTCMoth()根据世界时(UTC时间)返回，指定日期对象的月份。 getUTCDate()根据世界时(UTC时间)返回，指定日期对象的月份的第几天（从1开始）。 getUTCHours()根据世界时(UTC时间)返回，指定日期对象的小时（从0开始）。 getUTCMinutes()根据世界时(UTC时间)返回，指定日期对象的分钟（从0开始）。 getUTCSeconds()根据世界时(UTC时间)返回，指定日期对象的秒数（从0开始）。 getUTCMilliseconds()根据世界时(UTC时间)返回，指定日期对象的毫秒数（从0开始）。 set类setTime()以一个表示从1970-01-01 00:00:00 UTC开始的毫秒数来，为Date对象设置时间。 setFullYear()根据本地时间，指定日期对象的年份。 setYear()已废弃，使用setFullYear() setMoth()根据本地时间，指定日期对象的月份。 setDate()根据本地时间，指定日期对象的月份的第几天（从1开始）。 setHours()根据本地时间，指定日期对象的小时（从0开始）。 setMinutes()根据本地时间，指定日期对象的分钟（从0开始）。 setSeconds()根据本地时间，指定日期对象的秒数（从0开始）。 setMilliseconds()根据本地时间，指定日期对象的毫秒数（从0开始）。 setUTCDay()根据世界时(UTC时间)，指定日期对象的星期中的第几天（从0开始）。(没有对应的set方法) setUTCFullYear()根据世界时(UTC时间)，指定日期对象的年份。 setUTCMoth()根据世界时(UTC时间)，指定日期对象的月份。 setUTCDate()根据世界时(UTC时间)，指定日期对象的月份的第几天（从1开始）。 setUTCHours()根据世界时(UTC时间)，指定日期对象的小时（从0开始）。 setUTCMinutes()根据世界时(UTC时间)，指定日期对象的分钟（从0开始）。 setUTCSeconds()根据世界时(UTC时间)，指定日期对象的秒数（从0开始）。 setUTCMilliseconds()根据世界时(UTC时间)，指定日期对象的毫秒数（从0开始）。 to类（格式化方法）toJSON()返回一个符合JSON格式的日期字符串，与toISOString方法的返回结果完全相同.12var x = new Date();x.toJSON(); // "2018-06-12T01:39:03.350Z" 时区总是UTC toString()将日期对象转为字符串。和Date()一样都是返回字符串。123var x = new Date();x.toString(); // "Tue Jun 12 2018 09:39:03 GMT+0800 (中国标准时间)"Date(); // 不接受参数返回表示当前时间的字符串 toTimeString()将日期对象的时间部分转为字符串12var x = new Date();x.toTimeString(); // "09:39:03 GMT+0800 (中国标准时间)" toDateString()将日期对象的日期部分转为字符串12var x = new Date();x.toDateString(); // "Tue Jun 12 2018" toGMTString()已废弃 toUTCString()将日期对象转为用UTC时区表示的字符串12var x = new Date();x.toUTCString(); // "Tue, 12 Jun 2018 01:39:03 GMT" toISOString()将日期对象转为ISO格式的字符串12var x = new Date();x.toISOString(); // "2018-06-12T01:39:03.350Z" 时区总是UTC toLocaleString()将日期对象转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleString(); // "2018/6/12 上午9:39:03" toLocaleDateString()将日期对象的日期部分转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleDateString(); // "2018/6/12" toLocaleTimeString()将日期对象的时间部分转为字符串，根据本地规则格式化，因语言的不同而不同。12var x = new Date();x.toLocaleTimeString(); // "上午9:39:03" toSource()/toLocaleFormat()非标准的,不要使用。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>日期对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编写可维护的JavaScript》读书笔记之事件处理]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%8A%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文主要记录《编写可维护的JavaScript》一书中关于事件处理的一些编程技巧。加深自己的理解，应用到实际项目中。 事件处理在js中非常重要。所有js均通过事件处理来绑定到UI上。 反面实例12345678910111213141516function handleClick(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show';&#125;addListener(element,'click',handleClick); // 此处为封装的兼容性事件监听函数function addListener(ele, type, handler)&#123; if(ele.addEventListener)&#123; ele.addEventListener(type, handler); &#125;else&#123; ele.attachEvent('on' + type, function()&#123; return handler.call(ele, event); &#125;) &#125;&#125; 事件处理程序还包含了应用逻辑。应用逻辑是和应用相关的功能性代码，而不是和某一个用户行为完全相关的。 如上例，是点击某个元素，根据点击位置来显示目标元素。但有可能，同时有其他用户行为来，显示目标元素（例如，点击其他元素或，鼠标移入某个元素）。存在多个用户行为来显示目标元素的话，就要复制相同的代码。 第一步：隔离应用逻辑将上例代码中的应用逻辑，隔离出来1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event); &#125;, showPopup = function(event)&#123; var popup = document.getElementById('popup'); popup.style.left = event.clientX + 'px'; popup.style.top = event.clientY + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 应用逻辑全部转到myApplication.showPopup方法中，事件处理程序myApplication.handleClick只负责触发应用逻辑。 第二步：不分发事件对象 应用逻辑不应依赖于event事件对象。原因： 透明清晰的API 便于测试 上例代码中，应用逻辑代码只使用了事件对象的clientX和clientY属性。1234567891011121314var myApplication = &#123; handleClick = function(event)&#123; this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数 myApplication.handleClick方法，将x坐标和y坐标传入myApplication.showPopup方法中，可以很清晰的看到myApplication.showPopup方法希望传入的参数。 事件处理程序和阻止默认事件、阻止事件冒泡事件处理程序，应在进入应用逻辑之前，针对event对象做任何必要的操作，包括阻止默认事件和阻止事件冒泡12345678910111213141516var myApplication = &#123; handleClick = function(event)&#123; event.stopPropagation(); event.preventDefault(); this.showPopup(event.clientX,event.clientY); &#125;, showPopup = function(x,y)&#123; var popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.calssName = 'show'; &#125;&#125;addListener(element,'click',function(event)&#123; myApplication.handleClick(event);&#125;); // 此处为封装的兼容性事件监听函数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>读书笔记 编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script元素相关知识]]></title>
    <url>%2F2018%2F05%2F19%2Fscript%E5%85%83%E7%B4%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了，script元素的属性、动态加载js的方法、script标签在文档放置位置建议。js是阻塞式的语言。一般，页面中&lt;script&gt;标签出现，会使整个页面因脚本加载、解析、运行而出现等待，页面的下载和解析过程必须停下。 script元素属性type指示脚本的MIME类型。例如：type=&quot;text/javascript&quot; 、type=&quot;text/x-template&quot; MIME叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等。在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。 以上来自知乎：https://www.zhihu.com/question/60495696 src规定外部脚本的url defer规定脚本是否延迟执行。适用于外部脚本（ie4~ie7浏览器还适用于内联脚本）。当defer=&quot;defer&quot;时，脚本非阻塞式立即下载，和渲染后续文档元素，并行进行（异步），直到页面加载完成才执行脚本，在DOMContentLoaded事件触发之前完成（在window.onload之前执行）。 asyns非阻塞式立即下载，和渲染后续文档元素，并行进行（异步）。脚本下载完成后，立即执行。仅适用于外部脚本。 charset定义外部脚本文件中所使用的字符编码。 language不赞成使用，用type代替。规定脚本语言。 在页面加入script的几种方式1.用script标签直接插入脚本当浏览器遇到&lt;script&gt;标签，会停下来，下载外部文件代码(如果存在src引入的外部代码)，然后解析并运行这些代码。此过程，页面解析和用户交互是完全被阻塞的。可以利用script元素的属性改为非阻塞式。 2.动态加载脚本动态加载的js脚本，下载时是非阻塞的运行时是阻塞的。 2.1通过设置src属性动态加载脚本（异步）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.src = "https://cdn.bootcss.com/vue/2.5.16/vue.js";head.appendChild(script); 直到script标签插入文档，才会开始下载脚本。 2.2通过文本节点插入到script标签中（同步、低版本ie不支持）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.appendChild(document.createTextNode("var a = 1;"));head.appendChild(script); script标签插入文档，脚本立即执行。 2.3通过script标签text属性插入（同步） IE8-浏览器将&lt;script&gt;元素视为一个特殊的元素，不允许DOM访问其子节点，使用appendChild()方法或innerHTML属性都会报错 12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.text = "var a = 1;";head.appendChild(script); script标签插入文档，脚本立即执行。 2.4通过ajax插入脚本（异步）12345678910111213var xhr = new XMLHttpRequest();xhr.open('get','file1.js',true);xhr.onreadyStateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.text = xhr.responseText; document.getElementsByTagName('head')[0].appendChild('script'); &#125; &#125;&#125;xhr.send(null); js脚本必须与页面是同一个域。script标签插入文档，脚本立即执行。 2.5通过jq方法getScript插入脚本（异步）通过HTTP GET形式的加载JavaScript文件并运行它。123$.getScript('file1.js',function()&#123; alert('load');&#125;) 等同于12345678$.ajax(&#123; url:'file1.js', type:'get', dataType:'script', success:function()&#123; alert('load'); &#125;&#125;) 支持跨域脚本文件。异步添加脚本，访问该脚本的变量或函数时，应在回调函数中进行。 加载脚本并使用脚本代码的方法封装src引入js脚本封装12345678910111213141516171819function getUrlJs(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; if(typeof callback === 'function')&#123; script.onload = script.onreadyStateChange = function()&#123; /* * !script.readyState判断为现代浏览器 * script.readyState和script.readyState判断为ie低版本浏览器 */ if(!script.readyState || script.readyState === 'load' || script.readyState === 'complete')&#123; script.onload = script.onreadyStateChange = null; callback(); &#125; &#125; &#125; document.getElementsByTagName('head')[0].appendChild(script);&#125; ajax引入js脚本封装1234567891011121314151617181920212223242526272829function getAjaxJs(url,callback)&#123; var xhr = null; if(window.XMLHttpReques)&#123; xhr = new XMLHttpReques(); &#125;else if(window.ActiveXObject('Microsoft.XMLHTTP'))&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('get',url,true); xhr.onreadySateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; try&#123; // 现代浏览器 script.appenChild(document.createTextNode(xhr.responseText)) &#125;catch()&#123; // ie低版本浏览器 script.text = xhr.responseText; &#125; document.getElementsByTagName('head')[0].appendChild(script); callback(); &#125; &#125; &#125; xhr.send();&#125; script标签相关性能优化 与页面渲染相关(需要在页面渲染之前执行，如和css相关设置rem等)放到head标签内,其他与页面dom操作相关的脚本放到紧邻标签之前。 适当应用内部脚本（某个页面单独应用时），尤其移动端可减少http请求，优化性能。 一些需要触发某些条件才执行的脚本（一些事件或者判断客户端等），采用动态加载的方式添加到页面。 减少script标签引入外部脚本的数量，减少http请求。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>script标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server安装及配置]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp-server%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了，http-server的安装方式及端口的设置 1.安装进行全局安装1npm install http-server -g 2.启动服务2.1 使用默认端口8080直接在项目目录打开命令行工具执行http-server,即把项目资源托管到http://127.0.0.1:8080 2.2 自己设置端口直接在项目目录打开命令行工具执行 http-server -p 3000，即把项目资源托管到http://127.0.0.1:3000其中-p表示设置端口 3000为设置的端口号 3.关闭服务执行ctrl+c]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
