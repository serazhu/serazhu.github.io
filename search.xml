<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[script元素相关知识]]></title>
    <url>%2F2018%2F05%2F19%2Fscript%E5%85%83%E7%B4%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了，script元素的属性、动态加载js的方法、script标签在文档放置位置建议。js是阻塞式的语言。一般，页面中&lt;script&gt;标签出现，会使整个页面因脚本加载、解析、运行而出现等待，页面的下载和解析过程必须停下。 script元素属性type指示脚本的MIME类型。例如：type=&quot;text/javascript&quot; 、type=&quot;text/x-template&quot; MIME叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等。在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。 以上来自知乎：https://www.zhihu.com/question/60495696 src规定外部脚本的url defer规定脚本是否延迟执行。适用于外部脚本（ie4~ie7浏览器还适用于内联脚本）。当defer=&quot;defer&quot;时，脚本非阻塞式立即下载，和渲染后续文档元素，并行进行（异步），直到页面加载完成才执行脚本，在DOMContentLoaded事件触发之前完成（在window.onload之前执行）。 asyns非阻塞式立即下载，和渲染后续文档元素，并行进行（异步）。脚本下载完成后，立即执行。仅适用于外部脚本。 charset定义外部脚本文件中所使用的字符编码。 language不赞成使用，用type代替。规定脚本语言。 在页面加入script的几种方式1.用script标签直接插入脚本当浏览器遇到&lt;script&gt;标签，会停下来，下载外部文件代码(如果存在src引入的外部代码)，然后解析并运行这些代码。此过程，页面解析和用户交互是完全被阻塞的。可以利用script元素的属性改为非阻塞式。 2.动态加载脚本动态加载的js脚本，下载时是非阻塞的运行时是阻塞的。 2.1通过设置src属性动态加载脚本（异步）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.src = "https://cdn.bootcss.com/vue/2.5.16/vue.js";head.appendChild(script); 直到script标签插入文档，才会开始下载脚本。 2.2通过文本节点插入到script标签中（同步、低版本ie不支持）12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.appendChild(document.createTextNode("var a = 1;"));head.appendChild(script); script标签插入文档，脚本立即执行。 2.3通过script标签text属性插入（同步） IE8-浏览器将元素视为一个特殊的元素，不允许DOM访问其子节点，使用appendChild()方法或innerHTML属性都会报错 12345var head = document.getElementsByTagName('head')[0];var script = document.createElement('script');script.stype = "text/javascript";script.text = "var a = 1;";head.appendChild(script); script标签插入文档，脚本立即执行。 2.4通过ajax插入脚本（异步）12345678910111213var xhr = new XMLHttpRequest();xhr.open('get','file1.js',true);xhr.onreadyStateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.text = xhr.responseText; document.getElementsByTagName('head')[0].appendChild('script'); &#125; &#125;&#125;xhr.send(null); js脚本必须与页面是同一个域。script标签插入文档，脚本立即执行。 2.5通过jq方法getScript插入脚本（异步）通过HTTP GET形式的加载JavaScript文件并运行它。123$.getScript('file1.js',function()&#123; alert('load');&#125;) 等同于12345678$.ajax(&#123; url:'file1.js', type:'get', dataType:'script', success:function()&#123; alert('load'); &#125;&#125;) 支持跨域脚本文件。异步添加脚本，访问该脚本的变量或函数时，应在回调函数中进行。 加载脚本并使用脚本代码的方法封装src引入js脚本封装12345678910111213141516171819function getUrlJs(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; if(typeof callback === 'function')&#123; script.onload = script.onreadyStateChange = function()&#123; /* * !script.readyState判断为现代浏览器 * script.readyState和script.readyState判断为ie低版本浏览器 */ if(!script.readyState || script.readyState === 'load' || script.readyState === 'complete')&#123; script.onload = script.onreadyStateChange = null; callback(); &#125; &#125; &#125; document.getElementsByTagName('head')[0].appendChild(script);&#125; ajax引入js脚本封装1234567891011121314151617181920212223242526272829function getAjaxJs(url,callback)&#123; var xhr = null; if(window.XMLHttpReques)&#123; xhr = new XMLHttpReques(); &#125;else if(window.ActiveXObject('Microsoft.XMLHTTP'))&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('get',url,true); xhr.onreadySateChange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; try&#123; // 现代浏览器 script.appenChild(document.createTextNode(xhr.responseText)) &#125;catch()&#123; // ie低版本浏览器 script.text = xhr.responseText; &#125; document.getElementsByTagName('head')[0].appendChild(script); callback(); &#125; &#125; &#125; xhr.send();&#125; script标签相关性能优化 与页面渲染相关(需要在页面渲染之前执行，如和css相关设置rem等)放到head标签内,其他与页面dom操作相关的脚本放到紧邻标签之前。 适当应用内部脚本（某个页面单独应用时），尤其移动端可减少http请求，优化性能。 一些需要触发某些条件才执行的脚本（一些事件或者判断客户端等），采用动态加载的方式添加到页面。 减少script标签引入外部脚本的数量，减少http请求。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>script标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server安装及配置]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp-server%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了，http-server的安装方式及端口的设置 1.安装进行全局安装1npm install http-server -g 2.启动服务2.1 使用默认端口8080直接在项目目录打开命令行工具执行http-server,即把项目资源托管到http://127.0.0.1:8080 2.2 自己设置端口直接在项目目录打开命令行工具执行 http-server -p 3000，即把项目资源托管到http://127.0.0.1:3000其中-p表示设置端口 3000为设置的端口号 3.关闭服务执行ctrl+c]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
